[
  {
    "title": "SOLID Yazılım Prensipleri",
    "ID": "991bda4b-8705-4324-acad-a0595b0507e7",
    "description": "SOLID Yazılım Prensipleri",
    "content": "## S.O.L.I.D Nedir?\nS.O.L.I.D, yazılım geliştirirken sürdürülebilir kod yazmamızı sağlayan bir prensipler bütünüdür. Buradaki sürdürülebilirlikten kasıt; yazılım gereksinimleri değiştiğinde ya da mevcut yazılıma eklemeler yapıldığında sistemin buna direnç göstermemesi, en azından en az direnci göstermesi yani esnek olmasıdır. Bunların yanı sıra bakımının ve anlaşılmasının kolay olması gibi nedenler de sayılabilir.\n\nSOLID içerisinde 5 ana başlığa ayrılır:\n\n 1. **S**ingle Responsibility Principle (Tek Sorumluluk Prensibi)\n 2. **O**pen/Closed Principle (Açık Kapalı Prensibi) \n 3. **L**iskov SubstitutionPrinciple (Liskov’un Yerine geçme Prensibi) \n 4. **I**nterface Segregation Principle (Arayüz Ayrımı Prensibi) \n 5. **D**ependency Inversion Principle(Bağımlılıkların Tersine Çevrilmesi Prensibi)\n\nŞimdi bu prensipleri tek tek inceleyelim:\n\n## Single Responsibility Principle (Tek Sorumluluk Prensibi)\n\n> Her sınıf, metot, fonksiyon tek bir sorumluluğa sahip olmalıdır.\n\nŞayet bu kurala uymazsak ilerleyen süreçte bir değişikliğe gidildiğinde bunun etkisini birçok yerde görmüş oluruz. Nedeni ise bir yapıya birden fazla sorumluluk yüklenmesinden dolayıdır. Eğer değişikliklerden etkilenen yerler arasında sistemin birçok yerinde kullanılan bir yapımız da varsa maliyet gittikçe artacaktır.\n![single-1](https://skorskyfiles.blob.core.windows.net/$web/articles/SOLID/single-res-person.png)\n\n``` Java\npublic class Person {\n    public String firstName;\n\n    public void sendPasswordResetLink() {\n        ...\n    }\n}\n```\n\nYukarıdaki diyagrama ve koda baktığımızda Person sınıfı içerisinde sendPasswordResetLink() diye bir metot bulunmaktadır. Bu sınıfın asıl amacı kişilere ait bilgileri tutmaktır, şifre sıfırlama bağlantısı göndermek değil. Birden fazla sorumluluk yüklendiği için olası bir mail gönderme değişikliğinde bu sınıf da etkilenecektir.\n\nYukarıdaki UML diyagramını biraz daha düzenlersek aşağıdaki gibi bir yapı elde edilir.\n\n![single-res-2](https://skorskyfiles.blob.core.windows.net/$web/articles/SOLID/single-res-person-2.png)\n\n```Java\nclass Person {\n     public String firstName;\n}\n\nclass EmailService {\n    public void sendPasswordResetLink(Person person) {\n        ...\n    }\n}\n```\n\n## Open/Closed Principle (Açık Kapalı Prensibi)\n\n> Yapılarımız (sınıf, metot, fonksiyon) gelişime açık değişime kapalı olmalıdır.\n\nYazılımlar için zamanla değişim şüphesiz kaçınılmazdır; değişen iş kuralları, kullanılan harici kütüphaneler gibi başlıca nedenler örnek gösterilebilir. Bu prensibin anlatmak istediği şey yeni bir davranış ya da özellik eklemek istediğimiz durumda; yapmak istediğimiz değişikliği mevcut koda dokunmadan, değişimi sadece yeni kodlar üzerinden sağlamaktır.\n\n![open-closed](https://skorskyfiles.blob.core.windows.net/$web/articles/SOLID/open-closed.png)\n\n```Java\nclass Employee {\n    ...\n}\n\nclass EmployeeManager {\n    public void addEmployee(Object database, Employee employee) {\n        if (database instanceof OracleDatabase) {\n            ((OracleDatabase) database).addDatabase(employee);\n        }\n    }\n}\n\nclass OracleDatabase {\n    public void addDatabase(Employee employee) {\n        ...\n    }\n}\n```\n\nYukarıdaki koda ve diyagrama baktığımız zaman EmployeeManager adında bir sınıfımız mevcut ve gelen Employee sınıfına ait nesneyi veri tabanına kayıt ediyor. Veri tabanına kayıt etmeden önce hangi veri tabanı örneği geldiğini de if-else durumlarında kotrol edip tip dönüşümü sağlamaktadır. Yukarıdaki kod örneği maalesef Open-Closed için uygun değildir. Nedeni ise yeni bir veri tabanı eklenmek istediğinde başka bir if-else durumu açılacaktır, yeni eklenen veri tabanı kontrolü sağlanacaktır ve sürekli mevcut koda bir müdahalede bulunulacaktır. Bunu çözmenin yolu ise genelde soyutlamadan geçmektedir.\n\nYukarıdaki UML diyagramını biraz daha düzenlersek aşağıdaki gibi bir yapı elde edilir. Yeni bir eklemede mevcut koda dokunmaya gerek kalmıyor bu sayede. Kayıt işlemlerini MySQL üzerinde yapmak istediğimiz zaman MySQLDatabase adında bir sınıf oluşturup IDatabase arayüzünü uygulamamız yeterlidir. \n\n![open-closed-2](https://skorskyfiles.blob.core.windows.net/$web/articles/SOLID/open-closed-2.png)\n\n```Java\t\nclass Employee { \n...\n}\n\ninterface IDatabase {\n    void addDatabase(Employee employee);\n}\n\nclass EmployeeManager {\n    public void addEmployee(IDatabase database, Employee employee) {\n        database.addDatabase(employee);\n    }\n}\n\nclass OracleDatabase implements IDatabase {\n    @Override\n    public void addDatabase(Employee employee) {\n       ...\n    }\n}\n```\n\n## Liskov Substitution Principle (Liskov’un Yerine geçme Prensibi)\n\n\n> Alt sınıflardan oluşan nesnelerin, üst sınıfın nesneleri ile yer değiştirdiklerinde aynı davranışı sergilemesi gerekmektedir.\n\nAlt sınıflar, üst sınıflardan türediği için onların davranışlarını devralırlar. Eğer üst sınflara ait davranışları gerçekleştirmiyorlarsa davranışı yapan metotu muhtemelen boş bırakır ya da bir hata fırlatırız fakat bu işlemler kod kirliliğine ve gereksiz kod kalabalığına neden olmaktadır. Bunların yanı sıra projeye daha sonradan dahil olacak geliştiriciler için de sorun oluşturmaktadır. Geliştirici, sistemin sağlıklı yürüdüğünü düşünerek gerçekleştirilmeyen bir davranışı kullanmaya çalışabilir.\n\n![liskov-1](https://skorskyfiles.blob.core.windows.net/$web/articles/SOLID/liskov-1.png)\n\n```Java\nabstract class Logger {\n    public abstract void openConnection();\n    public abstract void closeConnection();\n    public abstract void log();\n}\n\nclass DatabaseLogger extends Logger {\n    @Override\n    public void openConnection() {\n        ...\n    }\n\n    @Override\n    public void closeConnection() {\n        ...\n    }\n\n    @Override\n    public void log() {\n        openConnection();\n        // LOG\n        closeConnection();\n    }\n}\n```\nYukarıdaki koda baktığımız zaman DatabaseLogger sınıfımız, Logger adlı sınıftan türemektedir. Başlangıç aşaması için bir problem görünmezken ilerleyen zamanlarda veri tabanı değil de bir dosyaya kayıt işlemi alınacağı zaman aşağıdaki gibi bir görünüm meydana gelecektir.\n\n![liskov-2](https://skorskyfiles.blob.core.windows.net/$web/articles/SOLID/liskov-2.png)\n\n```Java\nclass FileLogger extends Logger {\n    @Override\n    public void openConnection() {\n        new Exception(\"Not implemented!\");\n    }\n\n    @Override\n    public void closeConnection() {\n        new Exception(\"Not implemented!\");\n    }\n\n    @Override\n    public void log() {\n        // LOG\n    }\n}\n```\n\nBağlantı açma ve kapatma işlemleri veri tabanına aittir, bir dosyaya değil. Gereksiz hata fırlatmaları, kodun okunmasındaki zorluk, kod kalabalığı gibi birçok olaya neden olmaktadır. Burada bu işlemler bir ara sınıfa alınabilir.\n\n![liskov-3](https://skorskyfiles.blob.core.windows.net/$web/articles/SOLID/liskov-3.png)\n\n```Java\nabstract class Logger {\n    public abstract void log();\n}\n\nabstract class ConnectableLogger extends Logger {\n    public abstract void openConnection();\n    public abstract void closeConnection();\n}\n\nclass FileLogger extends Logger {\n    @Override\n    public void log() {\n        // LOG\n    }\n}\n\nclass DatabaseLogger extends ConnectableLogger {\n    @Override\n    public void openConnection() {\n        ...\n    }\n\n    @Override\n    public void closeConnection() {\n        ...\n    }\n\n    @Override\n    public void log() {\n        openConnection();\n        // LOG\n        closeConnection();\n    }\n}\n```\n\n## Interface Segregation Principle (Arayüz Ayrımı Prensibi)\n\n\n> Sınıflar, kullanmadığı metotları içeren arayüzleri uygulamaya zorlanmamalıdır.\n\nArayüzlerimizde genel olarak birçok operasyonel işlem barındırabiliriz fakat bu arayüzü uygulayan sınıfların, bazılarını kullanmama durumu olabilmektedir. Bir sınıf birden fazla arayüzü uygulaması özelliğiyle de birlikte bu prensip, bu tür durumlarda arayüzlerin ayrılmasını ve ihtiyaç halinde olanların kullanmasını söylemektedir.\n\n![interface-segre](https://skorskyfiles.blob.core.windows.net/$web/articles/SOLID/interface-segre.png)\n\n```Java\ninterface IWorker {\n    void eat() throws Exception;\n\n    void work();\n\n    void pay() throws Exception;\n}\n\nclass RobotWorker implements IWorker {\n\n    @Override\n    public void eat() throws Exception {\n        throw new Exception();\n    }\n\n    @Override\n    public void pay() throws Exception {\n        throw new Exception();\n    }\n\n    @Override\n    public void work() {\n      ...\n    }\n}\n```\n\nYukarıdaki diyagram incelendiğinde, şirket çalışanları IWorker arayüzünü uygulamaktadır; yemek yeme, ödeme alma, çalışma gibi davranışları gerçekleştirmektedir. Fakat daha sonradan bazı işler robotlar tarafından yapılmaya başlandı ya da dış kaynaktan birileri(outsource) de çalışmaya başladı. Bu durumda bazı davranışlar gerçekleşmeyecektir. Örneğin robotların yemek yeme ya da ödeme alma davranışını gerçekleştirememesi gibi ya da dış kaynaktan gelenlere verilmeyen yemek imkanı. Bu gerçekleşmeyen davranışların içlerini ya boş bırakma ya da hata fırlatma durumunda kalırız. Bu tür durumlarda bu prensip bizlere bu arayüzlerin ayrılmasını ve ihtiyaç halinde olanların kullanılmasını söylemektedir.\n\nYukarıdaki UML diyagramını biraz daha düzenlersek aşağıdaki gibi bir yapı elde edilir. work(), pay(), eat() davranışları başka arayüzlere aktarıldı ve ihtiyaç halinde olanlar uygulandı.\n\n![interface-segre-2](https://skorskyfiles.blob.core.windows.net/$web/articles/SOLID/interface-segre-2.png)\n\n```Java\ninterface IWorker {\n    void work();\n}\n\n\ninterface IEatableWorker {\n    void eat();\n}\n\ninterface IPayableWorker {\n    void pay();\n}\n\nclass Worker implements IWorker, IEatableWorker, IPayableWorker {\n\n    @Override\n    public void eat() {\n        ...\n    }\n\n    @Override\n    public void work() {\n        ...\n    }\n\n    @Override\n    public void pay() {\n        ...\n    }\n}\n\nclass RobotWorker implements IWorker {\n    @Override\n\n    public void work() {\n     ...\n    }\n}\n```\n## Dependency Inversion Principle (Bağımlılıkların Tersine Çevrilmesi Prensibi)\n> Yüksek seviye sınıflar, düşük seviye sınıflara bağlı olmamalıdır. Her ikisi de soyutlamalara bağlı olmalıdır.\n>Soyutlamalar, detaylara bağlı olmamalıdır. Detaylar, soyutlamalara bağlı olmalıdır.\n\n![dependency-inv](https://skorskyfiles.blob.core.windows.net/$web/articles/SOLID/dependency-inv.png)\n\n```Java\nclass ExceptionReporter {\n    private OracleDatabase oracleDatabase;\n\n    public ExceptionReporter() {\n        oracleDatabase = new OracleDatabase();\n    }\n\n    public void reportException(Exception exception) {\n        oracleDatabase.add(exception);\n    }\n}\n\nclass OracleDatabase {\n    public void add(Object object) {\n        System.out.println(\"added\");\n    }\n}\n```\n\nYukarıdaki diyagram ve kod incelendiğinde ExceptionReporter sınıfının (yüksek seviyeli sınıf), OracleDatabase sınıfına (düşük seviyeli sınıf) direkt olarak bağımlı olduğu görülmektedir. İleride veri tabanı olarak Oracle değil de MySQL kullanmak istersek maalesef bu sınıfa müdahale etmek zorunda kalacağız. Bu istenmeyen bir davranıştır. Bunun çözümünü ise buradaki bağımlılıkları soyutlayarak sağlayacağız.\n\nYukarıdaki UML diyagramını biraz daha düzenlersek aşağıdaki gibi bir yapı elde edilir.\n\n![dependency-inv-2](https://skorskyfiles.blob.core.windows.net/$web/articles/SOLID/dependency-inv-2.png)\n\n```Java\nclass ExceptionReporter {\n    private IDatabase database;\n\n    public ExceptionReporter(IDatabase database) {\n        this.database = database;\n    }\n\n    public void reportException(Exception exception) {\n        database.add(exception);\n    }\n}\n\ninterface IDatabase {\n    void add(Object object);\n}\n\nclass MySQLDatabase implements IDatabase {\n    @Override\n    public void add(Object object) {\n        ...\n    }\n}\n\nclass OracleDatabase implements IDatabase {\n    @Override\n\n    public void add(Object object) {\n        ...\n    }\n}\n```\n\n\n\n\n\n\n",
    "tags": [
      "design-patterns",
      "solid"
    ],
    "slug": "solid-yazilim-prensipleri",
    "categories": [
      "Software"
    ],
    "date": "2022-07-06 12:00",
    "cover": "solid.png",
    "createdAt": 1657068092424
  },
  {
    "ID": "ad28943f-266d-44ca-ad76-09319cf63b36",
    "title": "Design Patterns",
    "content": "## Design Patterns (Tasarım Kalıpları) Nedir?\n\nTasarım Desenleri (veya bir diğer kullanımla tasarım kalıpları) yazılımda sık karşılaşılan problemler için oluşturulmuş çözümlerdir. Kodunuz içerisinde sıklıkla karşılaşılan sorunları çözmek için özelleştirerek kullanabileceğiniz önceden hazırlanmış planlar olarak düşünebilirsiniz. Tasarım kalıpları bir fonksiyon, ya da sınıf gibi hazır olarak bulup kodunuza ekleyebileceğiniz parçalar değil, prorblem çözümü için kullanılan genel konseptlerdir.\n\nTasarım kalıpları gibi algoritmalar da problemleri çözmek için üretilmiş tipik çözümler olduğundan tasarım desenleri genelde algoritmalarla karıştırılır. Algoritmalar bir hedefe ulaşabilecek net bir eylemler kümesi tanımlarken, tasarım desenleri bir çözümün daha üst düzey bir tanımıdır. Aynı desenin iki farklı programa uygulanan kodu farklı olabilir.\n\nBir algoritmayı yemek tarifine benzetebiliriz. Kullanılacak malzemeler ve takip edilecek adımlar net olarak bellidir. Öte yandan bir tasarım kalıbı daha çok bir plan gibidir, sonuçta bekleneni ve özellikleri görürsünüz ama uygulama sırası ve şekli biraz daha size bağlıdır.\n\n\n## Design Pattern Ne Değildir?\nNesneler arası ilişkiler genellikle UML diyagramları ile gösterilir, bu sayede yazılımcılar arasında ortak bir iletişim dili oluşmuş olur.\n\nDesign patterns, doğrudan koda dönüştürülebilen bitmiş bir tasarım değildir. Birçok farklı durumda kullanılabilecek bir sorunun nasıl çözüleceğine ilişkin bir açıklama veya şablondur.\n\n## Design Pattern'e Neden İhtiyaç Duyarız?\n- Design Patterns, test edilmiş, kanıtlanmış geliştirme paradigmaları sağlayarak geliştirme sürecini hızlandırabilir.\n- Kodunuzu, daha basit tutmak gerektiğinde kodu daha anlamlı ve daha az karmaşık hale getirmeye yardımcı olurlar. \n- Büyük sorunlara neden olabilecek ince sorunları önlemeye yardımcı olur ve ayrıca kod okunabilirliğini artırır.\n- Ortak bir programlama sorununa karşı standart bir çözüm işlemi, yazılımın büyük ölçekte yeniden kullanılmasını sağlar.\n\n## Design Pattern Kategorileri\nYazılım tasarım kalıpları genel olarak 3 ana başlıkta incelenir. Bunlar şunlardır:\n\n1. Creational Patterns (Yaratımsal Kalıplar): Nesnelerin oluşturulmasında ve yönetilmesinde kullanılan bir desendir. Bu program akışında hangi nesneye ihtiyaç varsa onu oluşturmada esneklik ve kolaylık sağlar.\n2. Structural Patterns (Yapısal Kalıplar): Birden fazla sınıfın bir işi yerine getirirken nasıl davranacağını belirlemek için kullanılan desenlerdir. \n3. Behavioral Patterns (Davranışsal Kalıplar): Nesnelerin birbirleri ile ilişkisini düzenleyen desendir.\n\n\n### Creational Patterns (Yaratımsal Kalıplar)\n- Singleton Pattern\n- Factory Pattern\n- Abstract Factory Pattern\n- Builder Pattern\n- Prototype Pattern\n\n\n### Structural Patterns (Yapısal Kalıplar)\n- Adapter Pattern\n- Bridge Pattern\n- Filter Pattern\n- Composite Pattern\n- Decorator Pattern\n- Facade Pattern\n- Flyweight Pattern\n- Proxy Pattern\n\n### Behavioral Patterns (Davranışsal Kalıplar)\n- Command Pattern\n- Interpreter Pattern\n- Iterator Pattern\n- Mediator Pattern\n- Memento Pattern\n- Observer Pattern\n- Null Object Pattern\n- Strategy Pattern\n- State Pattern\n- Visitor Pattern\n\n> Bu tasarım kalıplarının bazılarını sonraki makalelerimizde inceleyeceğiz.\n\n## Anti Pattern Nedir?\nAnti patternler de bir patterndir ama yazılımsal olarak bir problemi kabul edilmiş bir pattern olarak kullanmak yerine sorunları özgün bir yöntem ile çözmek demektir. Yani tasarım kalıplarının tam zıttıdır diyebiliriz.\n\nProbleminizde bir anti pattern kullanmak ileride ciddi sorunlara yol açabilir. Ayrıca o problem için anti pattern olarak sayılan bir tasarım başka bir problem için uygun bir çözüm olabilir bunu unutmamak gerek. Bu anti patternler belgelenmiştir.\n\nAnti patternlerin belgelenmesinin avantajı programcının bu yöntemlerden mümkün olduğunca uzak durabilmesini sağlamak karşılaştırma yapabileceği bir kaynak sunmaktır.\n\nBazı anti patternler şunlardır:\n\n- Magic Push Button\n- Spagetti Coding\n- Functional Decomposition\n- Error Hidding\n- Swiss Army Knife\n- Cricular Dependency\n- God Object\n- Cargo Cult Programming\n- Golden Hammer\n- Boat Anchor\n- Copy Paste Programming\n\n\n\n\n",
    "slug": "design-patterns",
    "tags": [
      "design-patterns"
    ],
    "categories": [
      "Software"
    ],
    "description": "design-patterns",
    "date": "2022-07-07 12:00",
    "cover": "design-patterns.jpg",
    "createdAt": 1657143878432
  }
]